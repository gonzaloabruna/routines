import { NgModule, Component, OnInit, Input, Output, EventEmitter, AfterViewInit, ViewChild, ElementRef, Renderer2 } from '@angular/core';

// Añadir las opciones:
// Regenerar aleatoriamente
// Cambiar la key
// Cambiar la nota inicial
// Cambiar la nota final
// Cambiar el número de notas
// Cambiar la octava inicial
import * as Vex from 'vexflow';

@Component({
    selector: 'reading-trainer',
    templateUrl: 'reading-trainer.component.html',
    styleUrls: ['reading-trainer.component.css']
})

export class ReadingTrainerComponent implements OnInit, AfterViewInit {
    LIST_KEY_SIGNATURES = ['A', 'A#', 'Bb', 'B', 'C', 'C#', 'Db', 'D', 'D#', 'Eb', 'E', 'F', 'F#', 'G', 'G#', 'Ab'];
    LIST_NOTES_AVAILABLE = [
                            'e/3', 'f/3', 'g/3', 'a/3', 'b/3',
                            'c/4', 'd/4', 'e/4', 'f/4', 'g/4', 'a/4', 'b/4',
                            'c/5', 'd/5', 'e/5', 'f/5', 'g/5', 'a/5', 'b/5',
                            'c/6', 'd/6', 'e/6', 'f/6', 'g/6'
                            ];

    minIndexForNote: number;
    maxIndexForNote: number;
    minNote = 'a/3';
    maxNote = 'c/6';
    arrayOfNotes: Array<any>; // Array of keys, autogenerated
    startingOctave = 4; // Could start on the octave 4 or 5
    keySignature = 'C';
    numberOfNotes = 48;
    nextNoteCouldBe  = [
                        //0, // Unison
                        1, // Major 2nd
/*
                        2, // Major 3rd
                        3, // Perfect 4th
                        4, // Perfect 5th
                        5, // Major 6th
                        6, // Major 7th
                        7  // Octave
*/
                        ];

    @ViewChild('notesContainer') el: ElementRef;

    constructor(private rd: Renderer2) {}

    ngOnInit(): void {
        this.generateRandomNotes();
    }

    ngAfterViewInit(): void {
        this.initVexFlow();
    }

    private initVexFlow(): void {
        const div = this.el.nativeElement;
        const VF = Vex.Flow;
        const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);

        let width = window.screen.width - 80;

        // at least 25px per note:
        if (width < 25 * this.numberOfNotes) {
            width = 25 * this.numberOfNotes;
        }

        // Size our svg:
        renderer.resize(width, 300);

        // And get a drawing context:
        const context = renderer.getContext();

        // Create a stave at position 10, 40 of width 400 on the canvas.
        const stave = new VF.Stave(10, 40, width - 10).addKeySignature(this.keySignature);

        // Add a clef and time signature.
        stave.addClef('treble').addTimeSignature('4/4');

        // Connect it to the rendering context and draw!
        stave.setContext(context).draw();

        const notes = [];
        let numberRealNotes = 0;
        this.arrayOfNotes.forEach((iNote) => {
            if (numberRealNotes > 0 && numberRealNotes % 4 === 0) {
                notes.push(new Vex.Flow.BarNote());
            }
            notes.push(new VF.StaveNote({keys: iNote.keys, duration: iNote.duration}));
            numberRealNotes++;
        });

        const beams = VF.Beam.generateBeams(notes);
        Vex.Flow.Formatter.FormatAndDraw(context, stave, notes);
        beams.forEach((b) => { b.setContext(context).draw(); });
    }

    generateRandomNotes(): void {
        this.recalculateIndexesForNotes();

        this.arrayOfNotes = [];

        const firstNote = this.keySignature.replace('#', '').replace('b', '').toLowerCase() + '/' + this.startingOctave.toString();
        this.arrayOfNotes.push({keys: [firstNote], duration: 'q'});

        let index = 0;
        // Find the note position in the LIST_NOTES_AVAILABLE
        while (this.LIST_NOTES_AVAILABLE[index] !== firstNote) {
            index++;
        }
        while (this.arrayOfNotes.length < this.numberOfNotes) {
            // See how many numbers we have to add
            const numberToAddIndex = Math.floor((Math.random() * this.nextNoteCouldBe.length));
            const numberToAddValue = this.nextNoteCouldBe[numberToAddIndex];
            // If it is impossible to add it, decrease it
            if ((index + numberToAddValue) >= this.LIST_NOTES_AVAILABLE.length) {
                index = index - numberToAddValue;
            } else if ((index - numberToAddValue) < 0) {
                index = index + numberToAddValue;
            } else {
                // random value. to force a trend, if bigger than 30, increase it, if lower, move to back
                if (Math.floor((Math.random() * 100)) >= 30) {
                    index = index + numberToAddValue;
                } else {
                    index = index - numberToAddValue;
                }
            }

            if (index < this.minIndexForNote) {
                index = this.minIndexForNote;
            } else if (index > this.maxIndexForNote) {
                index = this.maxIndexForNote;
            }

            const newNote = this.LIST_NOTES_AVAILABLE[index];
            this.arrayOfNotes.push({keys: [newNote], duration: 'q'});
        }
    }

    private recalculateIndexesForNotes() {
        this.minIndexForNote = 0;
        while (this.LIST_NOTES_AVAILABLE[this.minIndexForNote] !== this.minNote) {
            this.minIndexForNote++;
        }

        this.maxIndexForNote = 0;
        while (this.LIST_NOTES_AVAILABLE[this.maxIndexForNote] !== this.maxNote) {
            this.maxIndexForNote++;
        }
    }

}
