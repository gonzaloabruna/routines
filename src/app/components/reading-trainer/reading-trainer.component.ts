import { NgModule, Component, OnInit, Input, Output, EventEmitter, AfterViewInit, ViewChild, ElementRef, Renderer2 } from '@angular/core';

// Añadir las opciones:
// Poder seleccionar la duración de la nota

import * as Vex from 'vexflow';

@Component({
    selector: 'reading-trainer',
    templateUrl: 'reading-trainer.component.html',
    styleUrls: ['reading-trainer.component.css']
})

export class ReadingTrainerComponent implements AfterViewInit {
    LIST_KEY_SIGNATURES = ['A', 'A#', 'Bb', 'B', 'C', 'C#', 'Db', 'D', 'D#', 'Eb', 'E', 'F', 'F#', 'G', 'G#', 'Ab'];
    LIST_NOTES_AVAILABLE = [
                            'e/3', 'f/3', 'g/3', 'a/3', 'b/3',
                            'c/4', 'd/4', 'e/4', 'f/4', 'g/4', 'a/4', 'b/4',
                            'c/5', 'd/5', 'e/5', 'f/5', 'g/5', 'a/5', 'b/5',
                            'c/6', 'd/6', 'e/6', 'f/6', 'g/6'
                            ];
    POSSIBLE_NUMBER_OF_NOTES = [16, 24, 32, 40, 48];

    minIndexForNote: number;
    maxIndexForNote: number;
    minNote = 'a/3';
    maxNote = 'c/6';
    firstNote = 'c/4';
    trendOneAscending = true;
    trendTwoAscending = false;
    arrayOfNotes: Array<any>; // Array of keys, autogenerated
    keySignature = 'C';
    numberOfNotes = 48;
    canHaveSilences = true;
    nextNoteCouldBe  = [
                        0, // Unison
                        1/*, // Major 2nd
                        2, // Major 3rd
/*
                        3, // Perfect 4th
                        4, // Perfect 5th
                        5, // Major 6th
                        6, // Major 7th
                        7  // Octave
*/
                        ];

    practiceUpToValue: number = 1;

    PRACTICE_OPTIONS = [
            {label: 'Major 2nd', value: 1},
            {label: 'Major 3rd', value: 2},
            {label: 'Perfect 4th', value: 3},
            {label: 'Perfect 5th', value: 4},
            {label: 'Major 6th', value: 5},
            {label: 'Major 7th', value: 6},
            {label: 'Octave', value: 7}
        ];
    noteDurationCouldBe = [
        'h',  // blanca
        'q',  // negra
        '8'  // corchea
    ];
    noteSilenceCouldBe = [
        'hr', // silencio de blanca
        'qr', // silencio de negra
        '8r'   // silencio de corchea
    ];

    @ViewChild('notesContainer') el: ElementRef;
    @ViewChild('notesContainer2') el2: ElementRef;

    constructor(private rd: Renderer2) {}

    ngAfterViewInit(): void {
        this.recalculateNotes();
    }

    recalculateNotes(): void {
        this.drawLine1();
        this.drawLine2();
    }

    calculateNextNoteCouldBe(): void {
        this.nextNoteCouldBe = [];
        for (let i = 0; i <= this.practiceUpToValue; i++) {
            this.nextNoteCouldBe.push(i);
        }
    }

    private calculateNoteDuration(): string {
        const randomNumber = Math.floor((Math.random() * 100));
        if (this.canHaveSilences === true && randomNumber < 10) { // Silences, not very often
            return 'qr';
        }

        return 'q';
    }

    private drawLine1(): void {
        this.generateRandomNotes(this.firstNote, this.trendOneAscending);
        const div = this.el.nativeElement;
        div.innerHTML = '';
        const VF = Vex.Flow;
        const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);

        let width = window.screen.width - 80;

        // at least 25px per note:
        if (width < 25 * this.numberOfNotes) {
            width = 25 * this.numberOfNotes;
        }

        // Size our svg:
        renderer.resize(width, 200);

        // And get a drawing context:
        const context = renderer.getContext();

        // Create a stave at position 10, 40 of width 400 on the canvas.
        const stave = new VF.Stave(10, 40, width - 10).addKeySignature(this.keySignature);

        // Add a clef and time signature.
        stave.addClef('treble').addTimeSignature('4/4');

        // Connect it to the rendering context and draw!
        stave.setContext(context).draw();

        const notes = [];
        let numberRealNotes = 0;
        this.arrayOfNotes.forEach((iNote) => {
            if (numberRealNotes > 0 && numberRealNotes % 4 === 0) {
                notes.push(new Vex.Flow.BarNote());
            }
            notes.push(new VF.StaveNote({keys: iNote.keys, duration: iNote.duration}));
            numberRealNotes++;
        });

        const beams = VF.Beam.generateBeams(notes);
        Vex.Flow.Formatter.FormatAndDraw(context, stave, notes);
        beams.forEach((b) => { b.setContext(context).draw(); });
    }

    private drawLine2(): void {
        const firstNote = this.arrayOfNotes[this.arrayOfNotes.length - 1]['keys'][0];
        this.generateRandomNotes(firstNote, this.trendTwoAscending);
        const div = this.el2.nativeElement;
        div.innerHTML = '';
        const VF = Vex.Flow;
        const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);

        let width = window.screen.width - 80;

        // at least 25px per note:
        if (width < 25 * this.numberOfNotes) {
            width = 25 * this.numberOfNotes;
        }

        // Size our svg:
        renderer.resize(width, 200);

        // And get a drawing context:
        const context = renderer.getContext();

        // Create a stave at position 10, 40 of width 400 on the canvas.
        const stave = new VF.Stave(10, 40, width - 10).addKeySignature(this.keySignature);

        // Add a clef and time signature.
        stave.addClef('treble').addTimeSignature('4/4');

        // Connect it to the rendering context and draw!
        stave.setContext(context).draw();

        const notes = [];
        let numberRealNotes = 0;
        this.arrayOfNotes.forEach((iNote) => {
            if (numberRealNotes > 0 && numberRealNotes % 4 === 0) {
                notes.push(new Vex.Flow.BarNote());
            }
            notes.push(new VF.StaveNote({keys: iNote.keys, duration: iNote.duration}));
            numberRealNotes++;
        });

        const beams = VF.Beam.generateBeams(notes);
        Vex.Flow.Formatter.FormatAndDraw(context, stave, notes);
        beams.forEach((b) => { b.setContext(context).draw(); });
    }

    private generateRandomNotes(firstNote: string, ascending: boolean): void {
        this.recalculateIndexesForNotes();

        this.arrayOfNotes = [];

        this.arrayOfNotes.push({keys: [firstNote], duration: 'q'});

        let index = 0;
        // Find the note position in the LIST_NOTES_AVAILABLE
        while (this.LIST_NOTES_AVAILABLE[index] !== firstNote) {
            index++;
        }
        while (this.arrayOfNotes.length < this.numberOfNotes) {
            const duration = this.calculateNoteDuration();
            if (duration.endsWith('r')) { // In case this is a rest
                this.arrayOfNotes.push({keys: ['b/4'], duration: duration});
            } else {
                // See how many numbers we have to add
                let numberToAddIndex = Math.floor((Math.random() * this.nextNoteCouldBe.length));
                let numberToAddValue = this.nextNoteCouldBe[numberToAddIndex];

                // To decrease the percentage of repetition of notes, if it takes the same note, recalculate it again
                if (numberToAddValue === 0) {
                    const randomNumber = Math.floor((Math.random() * 100));
                    if (randomNumber > 10) {
                        while (numberToAddValue === 0) {
                            numberToAddIndex = Math.floor((Math.random() * this.nextNoteCouldBe.length));
                            numberToAddValue = this.nextNoteCouldBe[numberToAddIndex];
                        }
                    }
                }

                // If it is impossible to add it, decrease it
                if ((index + numberToAddValue) >= this.LIST_NOTES_AVAILABLE.length) {
                    index = index - numberToAddValue;
                } else if ((index - numberToAddValue) < 0) {
                    index = index + numberToAddValue;
                } else {
                    const randomNumber = Math.floor((Math.random() * 100));
                    // random value. to force a trend, if bigger than 33, use the ascending or descending, if lower, move to back
                    if (randomNumber >= 33) {
                        if (ascending === true) {
                            index = index + numberToAddValue;
                        } else {
                            index = index - numberToAddValue;
                        }
                    } else {
                        if (ascending === true) {
                            index = index - numberToAddValue;
                        } else {
                            index = index + numberToAddValue;
                        }
                    }
                }

                if (index < this.minIndexForNote) {
                    index = this.minIndexForNote;
                } else if (index > this.maxIndexForNote) {
                    index = this.maxIndexForNote;
                }

                const newNote = this.LIST_NOTES_AVAILABLE[index];
                this.arrayOfNotes.push({keys: [newNote], duration: duration});
            }
        }
    }

    private recalculateIndexesForNotes() {
        this.minIndexForNote = 0;
        while (this.LIST_NOTES_AVAILABLE[this.minIndexForNote] !== this.minNote) {
            this.minIndexForNote++;
        }

        this.maxIndexForNote = 0;
        while (this.LIST_NOTES_AVAILABLE[this.maxIndexForNote] !== this.maxNote) {
            this.maxIndexForNote++;
        }
    }

}
